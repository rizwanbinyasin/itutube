package netflix.helpers;

import netflix.models.Credits;
import netflix.models.User;
import netflix.models.UserType;
import netflix.models.media.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class FileParser {

    public static List<User> fetchUsers(HashMap<String, Media> mediaMap) throws IOException {
        List<User> newUsers = new ArrayList<>();
        // Try to read the file
        String className = User.class.getSimpleName();
        Path path = Paths.get(PathsHelper.getDataFilePath(className));
        Scanner s = new Scanner(path);
        // Parse the lines in the file
        while (s.hasNext()) {
            String userLine = s.nextLine();
            String[] properties = userLine.split(";");
            String name = properties[0];
            UserType type = UserType.valueOf(properties[1]);
            ArrayList<Media> favoritesList = new ArrayList<>();
            String[] favoriteIds = trimArray(properties[2].split(","));
            for (String id : favoriteIds) {
                if (mediaMap.containsKey(id)) {
                    favoritesList.add(mediaMap.get(id));
                }
            }
            newUsers.add(new User(name, type, favoritesList));
        }
        return newUsers;
    }

    /**
     * Helper-function to trim white-space from strings inside an array.
     * @param toTrim An array of strings
     * @return array of trimmed strings
     */
    private static String[] trimArray(String[] toTrim) {
        for(int i = 0; i < toTrim.length; i++) {
            toTrim[i] = toTrim[i].trim();
        }
        return toTrim;
    }

    /**
     * Helper-function to format ratings from using commas to using dots (for parsing doubles directly from strings)
     * @param rating rating string loaded from file, containing a "," (comma)
     * @return The same string, where the comma is replaced with a period.
     */
    private static String formatRating(String rating) {
        return rating.replace(",", ".");
    }


    /**
     * @param line one line of the text file
     * @return A movie generated from the line.
     */
    private static Movie lineToMovie(String line) {
        String[] properties = trimArray(line.split(";"));
        String id = properties[0];
        String name = properties[1];
        Date releaseDate = new Date(Integer.parseInt(properties[2]), 1, 1);
        String[] categories = properties[3].split(", ");
        double rating = Double.parseDouble(formatRating(properties[4]));

        String description = FakeDataHelper.getLoremIpsum(100);
        Credits[] credits = FakeDataHelper.generateFakeCredits();
        String imageFileName = name + ".jpg";
        int runtime = FakeDataHelper.generateFakeRuntime();

        return new Movie(id, name, description, releaseDate, categories, rating, credits, imageFileName, runtime);
    }


    /**
     * @return An array of the movies generated by lineToMovie()
     */
    public static List<Movie> fetchMovies() throws FileNotFoundException {
        String path = PathsHelper.getDataFilePath(Movie.class.getSimpleName());
        File moviesFile = new File(path);
        Scanner s = new Scanner(moviesFile);
        ArrayList<Movie> movies = new ArrayList<>();
        while(s.hasNext()) {
            String line = s.nextLine();
            movies.add(lineToMovie(line));
        }
        return movies;
    }


    /**
     * @return all lines from the file in an array of series
     */
    public static List<Series> fetchSeries() throws FileNotFoundException {
        String path = PathsHelper.getDataFilePath(Series.class.getSimpleName());
        File seriesFile = new File(path);
        Scanner s = new Scanner(seriesFile);
        ArrayList<Series> seriesList = new ArrayList<>();
        while(s.hasNext()) {
            String line = s.nextLine();
            Series series = lineToSeries(line);
            seriesList.add(series);
        }
        return seriesList;
    }


    /**
     * @param series The series the episodes are part of
     * @param season The season the episodes are part of
     * @param episodeAmount The amount of episodes there are to fetch from the season
     * @return An array of episodes from the provided season and series
     */
    private static List<Episode> fetchEpisodes(Series series, Season season, int episodeAmount) {
        ArrayList<Episode> episodes = new ArrayList<>();
        for(int i = 1; i <= episodeAmount; i++) {
            String id = FakeDataHelper.generateFakeId();
            String name = season.getName() + "E" + i;
            String description = FakeDataHelper.getLoremIpsum(200);
            Date releaseDate = season.getReleaseDate();
            String[] categories = season.getCategories();
            double rating = FakeDataHelper.generateFakeRating();
            Credits[] credits = season.getCredits();
            String imageFileName = season.getImageFileName();
            int runtime = FakeDataHelper.generateFakeRuntime();

            episodes.add(new Episode(id, name, description, releaseDate, categories, rating, credits, imageFileName, runtime, season, series));
        }
        return episodes;
    }


    /**
     * @param series The series the season is part of
     * @param line The line of seasons and episodes
     * @return An array of all seasons in the given series
     */
    private static Season[] fetchSeasons(Series series, String line) {
        ArrayList<Season> seasons = new ArrayList<>();
        String[] seasonsString = trimArray(line.split(","));

        for(String s : seasonsString) {
            int seasonNumber = Integer.parseInt(s.split("-")[0]);
            int episodeAmount = Integer.parseInt(s.split("-")[1]);
            String id = FakeDataHelper.generateFakeId();
            String name = series.getName() + " S" + seasonNumber;
            String description = FakeDataHelper.getLoremIpsum(150);

            Date firstSeasonDate = series.getReleaseDate();
            Calendar c = Calendar.getInstance();
            c.setTime(firstSeasonDate);
            c.add(Calendar.YEAR, seasonNumber-1);
            Date currentSeasonDate = c.getTime();

            String[] categories = series.getCategories();
            double rating = FakeDataHelper.generateFakeRating();
            Credits[] credits = series.getCredits();
            String imageFileName = series.getImageFileName();

            Season season = new Season(id, name, description, currentSeasonDate, categories, rating, credits, imageFileName, series);


            List<Episode> episodes = fetchEpisodes(series, season, episodeAmount);
            season.setEpisodes(episodes);
            seasons.add(season);
        }
        Season[] seasonArray = new Season[seasons.size()];
        return seasons.toArray(seasonArray);
    }


    /**
     * @param line The start-date and end-date (if it exists) as a string
     * @return An array of the start-date and end-date as Date-objects. If there is no '-' after the first date, the end-date will be the same. Else, the end date will be null (if the show is ongoing).
     */
    private static Date[] getSeriesDates(String line) {
        Date releaseDate = new Date(Integer.parseInt(line.substring(0,4)), 1, 1);
        Date endDate = releaseDate;
        if(line.length() == 9) {
            endDate = new Date(Integer.parseInt(line.substring(5, 9)), 1, 1);
        }
        else if(line.length() > 4) {
            endDate = null;
        }
        return new Date[]{releaseDate, endDate};
    }


    /**
     * @param line a line of text from the series file
     * @return a series created from the parameters in the line
     */
    private static Series lineToSeries(String line) {
        String[] properties = trimArray(line.split(";"));
        String id = properties[0];
        String name = properties[1];

        Date[] dates = getSeriesDates(properties[2]);
        Date releaseDate = dates[0];
        Date endDate = dates[1];

        String[] categories = properties[3].split(",");
        double rating = Double.parseDouble(formatRating(properties[4]));

        String description = FakeDataHelper.getLoremIpsum(175);
        Credits[] credits = FakeDataHelper.generateFakeCredits();
        String imageFileName = name + ".jpg";

        Series series = new Series(id, name, description, releaseDate, endDate, categories, rating, credits, imageFileName);
        Season[] seasons = fetchSeasons(series, properties[5]);
        series.setSeasons(seasons);

        return series;
    }
}
